### 一、外观模式介绍

#### 1. 解决的问题

主要解决访问复杂系统的内部子系统的复杂度问题，简化客户端与其子系统的接口。

#### 2. 定义

外观模式是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。

#### 3. 应用场景

* 需要一个指向复杂子系统的直接接口，且该接口的功能有限，可以使用外观模式。
* 需要将子系统组织为多层结构，可以使用外观模式。


### 二、外观模式优缺点

#### 1. 优点

* 可以让代码独立于复杂子系统。

#### 2. 缺点

* 外观可能成为与程序中所有类都耦合的上帝对象。

### 三、外观模式应用实例：类型转换器

#### 1. 实例场景

在我们的工作中，常常会遇到一些类型转换的问题，比如将一个数组转换成字符串等，我们通常会用一些第三方工具类库来实现，比如 `Hutool` ，这种工具类库其实就是包含外观模式的思想，我们无需关注内部如何实现类型转换，只需根据方法说明传参即可获取我们想要的转换结果。

今天就以 `Hutool` 的 类型转换为例，介绍一下如何使用外观模式。

#### 2. 外观模式实现

##### 2.1 工程结构

##### 2.2 代码实现

##### 2.3 测试验证

###### 2.3.1 测试验证类

###### 2.3.2 测试结果

### 四、外观模式结构

![外观模式-模式结构图](images\外观模式-模式结构图.png)

1. **外观**（Facade）提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动不见。

2. 创建**附加外观**（Additional Facade）类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都可使用附加外观。

3. **复杂子系统**（Complex Subsystem）有数十个不同对象构成。如果要用这些对象完成有意义的工作，必须了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正确格式的数据。

   子系统类不会意识到外观的存在，它们在系统内运作并且相互之间可直接进行交互。

4. **客户端**（Client）使用外观代替对子系统对象的直接调用。

**设计模式并不难学，其本身就是多年经验提炼出的开发指导思想，关键在于多加练习，带着使用设计模式的思想去优化代码，就能构建出更合理的代码。**

> 源码地址：[https://github.com/yiyufxst/design-pattern-java](https://github.com/yiyufxst/design-pattern-java)
>
> 参考资料：
> 小博哥重学设计模式：[https://github.com/fuzhengwei/itstack-demo-design](https://github.com/fuzhengwei/itstack-demo-design)
> 深入设计模式：[https://refactoringguru.cn/design-patterns/catalog](https://refactoringguru.cn/design-patterns/catalog)