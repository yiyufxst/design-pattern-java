### 一、享元模式介绍

#### 1. 解决的问题

主要解决载有大量对象时，可能造成内存溢出的问题。

#### 2. 定义

享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，能在有限的内存容量中载入更多对象。

#### 3. 应用场景

* 在程序必须支持大量对象且没有足够的内存容量时使用享元模式。


### 二、享元模式优缺点

#### 1. 优点

* 程序中有很多相似对象，那就能节省大量内存。

#### 2. 缺点

* 可能需要牺牲执行速度来换取内存，因为每次调用向享元方法时都需要重新计算部分情景数据。
* 代码会变得更加复杂。如：为什么要拆分一个实体的状态？

### 三、享元模式应用实例：

#### 1. 实例场景

#### 2. xx模式实现

##### 2.1 工程结构

##### 2.2 代码实现

##### 2.3 测试验证

###### 2.3.1 测试验证类

###### 2.3.2 测试结果

### 四、享元模式结构

![享元模式-模式结构图](D:\Notes\初学设计模式\images\享元模式-模式结构图.png)

享元模式只是一种优化。在应用该模式之前，要确定程序中存在大量类似对象同时占用内存相关的内存消耗问题，并且确保该问题无法使用其他更好的方式来解决。

1. **享元**（Flyweight）类包含原始对象中部分能在多个对象中共享的状态。

   同一享元对象可在许多不同情景中使用。享元中存储的状态被称为 “内在状态” 。传递给享元方法的状态被称为 “外在状态” 。

2. **情景** （Context）类包含原始对象中各不相同的外在状态。

   情景与享元对象组合在一起就能表示原始对象的全部状态。

3. 通常情况下，原始对象的行为会保留在享元类中。因此享元方法必须提供部分外在状态作为参数。但也可以将行为移动到情景类中，然后将连入的享元作为单纯的数据对象。

4. **客户端**（Client）负责计算或者存储享元的外在状态。在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数。

5. **享元工程**（Flyweight Factory）会对已有享元的缓存池进行管理。

   有了工厂后，客户端就无需直接创建享元，只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，找到满足条件的享元将其返回，否则根据参数新建享元。

**设计模式并不难学，其本身就是多年经验提炼出的开发指导思想，关键在于多加练习，带着使用设计模式的思想去优化代码，就能构建出更合理的代码。**

> 源码地址：[https://github.com/yiyufxst/design-pattern-java](https://github.com/yiyufxst/design-pattern-java)
>
> 参考资料：
> 小博哥重学设计模式：[https://github.com/fuzhengwei/itstack-demo-design](https://github.com/fuzhengwei/itstack-demo-design)
> 深入设计模式：[https://refactoringguru.cn/design-patterns/catalog](https://refactoringguru.cn/design-patterns/catalog)